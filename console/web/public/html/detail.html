<!--
Detail view panel using modular widget system.
Widgets auto-load based on available metrics. Functions: openDetailView(), closeDetailView().
-->
<script>
    // UI state managed in window.app (index.html)

    // Chart rendering helper for widgets (global for widget access)
    window.renderMetricChart = function(canvasId, label, data, color, suffix = '') {
        const ctx = document.getElementById(canvasId);
        if (!ctx) return;

        // Destroy existing chart if it exists
        if (window.app.charts[canvasId]) {
            window.app.charts[canvasId].destroy();
        }

        const timestamps = data.map(d => d.timestamp * 1000);
        const values = data.map(d => d.value);
        const labels = timestamps.map(ts => {
            const date = new Date(ts);
            return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
        });

        window.app.charts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: values,
                    borderColor: color,
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.9)',
                        titleColor: '#cdd6f4',
                        bodyColor: '#cdd6f4',
                        borderColor: '#45475a',
                        borderWidth: 1,
                        displayColors: false,
                        callbacks: {
                            title: function(context) { return context[0].label; },
                            label: function(context) { return context.parsed.y.toFixed(1) + suffix; }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            color: '#6c7086',
                            stepSize: 25,
                            callback: function(value) { return value + suffix; }
                        },
                        grid: { color: '#313244', drawTicks: false }
                    },
                    x: {
                        ticks: { color: '#6c7086', maxTicksLimit: 6, maxRotation: 0, minRotation: 0 },
                        grid: { display: false }
                    }
                }
            }
        });
    };

    async function openDetailView() {
        const agent = getSelectedAgent();
        if (!agent) {
            console.error('No agent selected');
            return;
        }

        // If detail view is already open for this agent, just refresh (don't re-render)
        if (window.app.ui.detailViewOpen && window.app.ui.currentAgentId === agent.id) {
            return;
        }

        window.app.ui.detailViewOpen = true;
        window.app.ui.currentAgentId = agent.id;

        // Register refresh function with global clock
        window.globalClock.register(refreshDetailView);

        try {
            const panel = document.getElementById('detail-panel');
            panel.classList.remove('detail-panel-empty');

            // Check if this is a pending invite
            if (!agent.valid && agent.pending_invite) {
                renderPendingInviteView(agent, panel);
                return;
            }

            // Check if this is an invite without data
            if (agent.type === 'invite') {
                renderInviteDetailView(agent, panel);
                return;
            }

            // Check if this is a mail-only host
            const row = document.querySelector(`.agent-row[data-entity-id="${agent.id}"]`);
            if (row && row.dataset.mailOnly === 'true') {
                renderMailOnlyView(agent, panel);
                return;
            }

            // Fetch metric tables for this agent
            const response = await fetch(`/api/agents/${agent.id}/tables`);
            const data = await response.json();
            const tables = data.tables || [];

            // Build detail view with header and widget container
            const displayName = agent.display_name || agent.original_hostname || agent.hostname || agent.id;
            panel.innerHTML = `
                <div class="detail-header">
                    <h2><span class="status-dot ${agent.status}"></span>${displayName}<span class="edit-name-btn" id="edit-name-btn" title="Edit display name">✎</span></h2>
                    <div class="detail-header-right">
                        <span class="detail-status">${agent.id}</span>
                        <span class="status-warnings" id="status-warnings"></span>
                    </div>
                </div>
                <div class="detail-content">
                    <div id="widgets-container"></div>
                    <div id="metrics-section" class="metrics-section">
                        <h3 id="metrics-header">All Values</h3>
                        <div id="metrics-list" class="metrics-list">
                            <span class="loading-text">Loading metrics...</span>
                        </div>
                    </div>
                </div>
            `;

            // Add edit name handler
            document.getElementById('edit-name-btn').addEventListener('click', () => {
                const currentName = agent.display_name || '';
                const placeholder = agent.original_hostname || agent.hostname || agent.id;
                const newName = prompt(`Enter display name (leave empty to use "${placeholder}"):`, currentName);
                if (newName !== null) {
                    updateHostName(agent.id, newName.trim());
                }
            });

            // Render widgets
            const widgetsContainer = document.getElementById('widgets-container');
            LumenmonWidgets.renderAll(widgetsContainer, agent, tables);

            // Load additional data
            loadMetrics(agent.id);
            loadSystemStatus(agent.id, agent.type || 'agent');
        } catch (error) {
            console.error('Error opening detail view:', error);
            addLog(`error opening detail: ${error.message}`, 'error');
        }
    }

    async function refreshDetailView() {
        if (!window.app.ui.detailViewOpen) return;

        const agent = getSelectedAgent();
        if (!agent) return;

        try {
            // Fetch fresh data
            const response = await fetch(`/api/agents/${agent.id}/tables`);
            const data = await response.json();
            const tables = data.tables || [];

            // Update widgets with new data
            const widgetsContainer = document.getElementById('widgets-container');
            if (widgetsContainer) {
                LumenmonWidgets.updateAll(widgetsContainer, agent, tables);
            }

            // Update metrics table
            await loadMetrics(agent.id);
        } catch (error) {
            console.error('Error refreshing detail view:', error);
        }
    }

    function toggleOkMetrics() {
        const content = document.getElementById('ok-metrics-content');
        const header = document.querySelector('.metrics-ok-header .expand-hint');
        if (!content) return;

        window.okMetricsExpanded = !window.okMetricsExpanded;
        content.classList.toggle('hidden-section');
        if (header) {
            header.textContent = window.okMetricsExpanded ? '▼' : '▶';
        }
    }

    function closeDetailView() {
        window.app.ui.detailViewOpen = false;
        window.app.ui.currentAgentId = null;
        window.globalClock.unregister(refreshDetailView);

        const panel = document.getElementById('detail-panel');
        panel.classList.add('detail-panel-empty');
        panel.innerHTML = '<span class="detail-placeholder">← Select an agent and press <kbd>Enter</kbd></span>';
    }

    function renderPendingInviteView(agent, panel) {
        const inviteData = agent.pending_invite;
        const installCommand = inviteData.install_command ||
            `curl -sSL https://raw.githubusercontent.com/chriopter/lumenmon/main/agent/install.sh | bash -s '${inviteData.invite_url}'`;
        const emailAddress = inviteData.email_address || '';

        panel.innerHTML = `
            <div class="detail-header-tui">
                <span class="status-dot offline"></span> ${agent.id} <span class="tui-badge">pending</span>
            </div>
            <div class="detail-content-tui">
                <div class="tui-box">
                    <h3>install command</h3>
                    <div class="tui-box-content" id="copy-install-cmd">${installCommand}</div>
                </div>
                <div class="tui-box">
                    <h3>invite url</h3>
                    <div class="tui-box-content" id="copy-invite-url">${inviteData.invite_url}</div>
                </div>
                ${emailAddress ? `
                <div class="tui-box">
                    <h3>email address (for smtp mail forwarding)</h3>
                    <div class="tui-box-content" id="copy-email-addr">${emailAddress}</div>
                </div>
                ` : ''}
                <div class="tui-footer">
                    <span class="pulse-dot"></span> waiting for data...
                </div>
            </div>
        `;

        // Click handlers for copying
        const installBox = document.getElementById('copy-install-cmd');
        const urlBox = document.getElementById('copy-invite-url');
        const emailBox = document.getElementById('copy-email-addr');

        const flashCopy = (box, message) => {
            const header = box.previousElementSibling;
            const originalText = header.textContent;
            box.style.background = '#a6e3a1';
            box.style.color = '#1e1e2e';
            header.textContent = message;
            header.style.color = '#a6e3a1';
            setTimeout(() => {
                box.style.background = '';
                box.style.color = '';
                header.textContent = originalText;
                header.style.color = '';
            }, 500);
        };

        installBox.addEventListener('click', async () => {
            if (navigator.clipboard) {
                await navigator.clipboard.writeText(installCommand);
                flashCopy(installBox, 'copied!');
                addLog('copied install command', 'success');
            } else {
                addLog('clipboard unavailable (use https or localhost)', 'error');
            }
        });

        urlBox.addEventListener('click', async () => {
            if (navigator.clipboard) {
                await navigator.clipboard.writeText(inviteData.invite_url);
                flashCopy(urlBox, 'copied!');
                addLog('copied invite url', 'success');
            } else {
                addLog('clipboard unavailable (use https or localhost)', 'error');
            }
        });

        if (emailBox) {
            emailBox.addEventListener('click', async () => {
                if (navigator.clipboard) {
                    await navigator.clipboard.writeText(emailAddress);
                    flashCopy(emailBox, 'copied!');
                    addLog('copied email address', 'success');
                } else {
                    addLog('clipboard unavailable (use https or localhost)', 'error');
                }
            });
        }
    }

    async function renderInviteDetailView(invite, panel) {
        panel.innerHTML = `
            <div class="detail-header">
                <h2><span class="status-dot online"></span>Invite: ${invite.id}</h2>
                <span class="detail-status">${invite.id}</span>
            </div>
            <div class="detail-content">
                <div class="invite-details-section">
                    <div class="invite-status-info">
                        <div class="invite-status-title">Invite Status: Active</div>
                        <div class="invite-status-text">
                            This invite is waiting for an agent to connect.
                            <br><br>
                            The invite URL with credentials was shown once when created and cannot be retrieved again for security reasons.
                            <br><br>
                            To generate a new invite URL, press <kbd>i</kbd>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    async function renderMailOnlyView(agent, panel) {
        // Render a simplified view for mail-only hosts (no agent, just mail)
        const displayName = agent.display_name || agent.id;

        panel.innerHTML = `
            <div class="detail-header">
                <h2><span class="status-dot warning"></span>${displayName}<span class="edit-name-btn" id="edit-name-btn" title="Edit display name">✎</span></h2>
                <div class="detail-header-right">
                    <span class="detail-status">${agent.id}</span>
                    <span class="tui-badge">mail only</span>
                </div>
            </div>
            <div class="detail-content">
                <div id="widgets-container"></div>
                <div class="mail-only-info">
                    <p>This host has no agent installed - it only sends mail via SMTP.</p>
                    <p>To install the monitoring agent, create an invite with <kbd>i</kbd></p>
                </div>
            </div>
        `;

        // Add edit name handler
        document.getElementById('edit-name-btn').addEventListener('click', () => {
            const currentName = agent.display_name || '';
            const newName = prompt(`Enter display name (leave empty to use "${agent.id}"):`, currentName);
            if (newName !== null) {
                updateHostName(agent.id, newName.trim());
            }
        });

        // Render only the messages widget for mail-only hosts
        const widgetsContainer = document.getElementById('widgets-container');
        if (widgetsContainer && window.LumenmonWidgets) {
            // Just render messages widget - use empty tables list to skip metric widgets
            LumenmonWidgets.renderAll(widgetsContainer, agent, []);
        }
    }

    async function updateHostName(agentId, newName) {
        try {
            const response = await fetch(`/api/agents/${agentId}/name`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName })
            });
            const data = await response.json();
            if (data.success) {
                addLog(`name updated: ${newName || '(cleared)'}`, 'success');
                // Refresh to show new name
                await fetchAgents();
                // Re-open detail view to reflect change
                setTimeout(() => openDetailView(), 100);
            } else {
                addLog(`failed to update name: ${data.error}`, 'error');
            }
        } catch (error) {
            addLog(`error updating name: ${error.message}`, 'error');
        }
    }

    async function loadMetrics(agentId) {
        try {
            const response = await fetch(`/api/agents/${agentId}/tables`);
            if (!response.ok) throw new Error(`HTTP error ${response.status}`);

            const data = await response.json();
            const metricsList = document.getElementById('metrics-list');
            if (!metricsList) return;

            if (!data.tables || data.tables.length === 0) {
                metricsList.innerHTML = '<span class="no-data-text">no database entries found</span>';
                return;
            }

            const previousValues = window.metricsPreviousValues || {};
            const currentValues = {};
            const problemMetrics = [];
            const okMetrics = [];

            // Process and categorize metrics
            data.tables.forEach(table => {
                const metricName = table.metric_name;
                const columns = table.columns || {};
                const metadata = table.metadata || {};
                const staleness = table.staleness || {};

                const value = columns.value;
                currentValues[metricName] = value;
                const flashClass = (previousValues[metricName] !== undefined && previousValues[metricName] !== value) ? 'value-flash' : '';

                const isStale = staleness.is_stale || false;
                const timeUntilNext = staleness.next_update_in || 0;
                const isOneTime = columns.interval === 0;
                const gracePeriod = 1;
                const isOverdue = !isOneTime && timeUntilNext < -gracePeriod;

                let nextUpdateText = '-';
                if (isOneTime) {
                    nextUpdateText = 'once';
                } else if (columns.timestamp > 0) {
                    if (timeUntilNext >= 0) {
                        if (timeUntilNext < 60) nextUpdateText = `in ${timeUntilNext}s`;
                        else if (timeUntilNext < 3600) nextUpdateText = `in ${Math.floor(timeUntilNext / 60)}m`;
                        else nextUpdateText = `in ${Math.floor(timeUntilNext / 3600)}h`;
                    } else if (timeUntilNext >= -gracePeriod) {
                        nextUpdateText = 'now';
                    } else {
                        const overdue = Math.abs(timeUntilNext);
                        if (overdue < 60) nextUpdateText = `${overdue}s ago`;
                        else if (overdue < 3600) nextUpdateText = `${Math.floor(overdue / 60)}m ago`;
                        else nextUpdateText = `${Math.floor(overdue / 3600)}h ago`;
                    }
                }

                const health = table.health || {};
                const isOutOfBounds = health.out_of_bounds || false;
                const isWarningBounds = health.warning_out_of_bounds || false;

                const latestVersion = window.app?.data?.latestVersion;
                const isVersionMetric = metricName === 'generic_agent_version';
                const versionValue = columns.value_text;
                const isOutdated = isVersionMetric && window.isAgentVersionOutdated
                    ? window.isAgentVersionOutdated(versionValue, latestVersion)
                    : false;

                const hasProblem = isOutdated || isOutOfBounds || isStale || isWarningBounds;
                const rowClass = (isOutOfBounds || isStale)
                    ? (isOutOfBounds ? 'error-row' : 'stale-row')
                    : ((isOutdated || isWarningBounds) ? 'warning-row' : '');

                let valueCellClass = '';
                let minCellClass = '';
                let maxCellClass = '';

                if (isOutdated) {
                    valueCellClass = 'status-warning';
                }

                if (isOutOfBounds || isWarningBounds) {
                    const numericValue = Number(value);
                    const severityClass = isOutOfBounds ? 'status-error' : 'status-warning';
                    valueCellClass = severityClass;

                    if (!Number.isNaN(numericValue)) {
                        if (columns.min_value !== null && columns.min_value !== undefined && numericValue < Number(columns.min_value)) {
                            minCellClass = severityClass;
                        }
                        if (columns.max_value !== null && columns.max_value !== undefined && numericValue > Number(columns.max_value)) {
                            maxCellClass = severityClass;
                        }
                        if (!minCellClass && columns.warn_min_value !== null && columns.warn_min_value !== undefined && numericValue < Number(columns.warn_min_value)) {
                            minCellClass = 'status-warning';
                        }
                        if (!maxCellClass && columns.warn_max_value !== null && columns.warn_max_value !== undefined && numericValue > Number(columns.warn_max_value)) {
                            maxCellClass = 'status-warning';
                        }
                    }
                }

                const metricData = {
                    metricName,
                    columns,
                    metadata,
                    flashClass,
                    rowClass,
                    nextUpdateText,
                    isOverdue,
                    agentId,
                    valueCellClass,
                    minCellClass,
                    maxCellClass
                };
                if (hasProblem) {
                    problemMetrics.push(metricData);
                } else {
                    okMetrics.push(metricData);
                }
            });

            window.metricsPreviousValues = currentValues;

            // Helper to build table row
            const fmtVal = (v) => v !== null && v !== undefined ? v : '-';
            const buildRow = (m) => {
                const realClass = `type-real ${m.columns.value_real !== null ? m.flashClass : ''} ${m.columns.value_real !== null ? m.valueCellClass : ''}`.trim();
                const intClass = `type-integer ${m.columns.value_int !== null ? m.flashClass : ''} ${m.columns.value_int !== null ? m.valueCellClass : ''}`.trim();
                const textClass = `type-text ${m.columns.value_text !== null ? m.valueCellClass : ''}`.trim();
                let row = `<tr class="${m.rowClass}">`;
                row += `<td class="metric-name">${m.metricName}</td>`;
                row += `<td>${m.columns.timestamp || '-'}</td>`;
                row += `<td class="${realClass}" data-full="${fmtVal(m.columns.value_real)}">${fmtVal(m.columns.value_real)}</td>`;
                row += `<td class="${intClass}" data-full="${fmtVal(m.columns.value_int)}">${fmtVal(m.columns.value_int)}</td>`;
                row += `<td class="${textClass}" data-full="${fmtVal(m.columns.value_text)}">${fmtVal(m.columns.value_text)}</td>`;
                row += `<td class="${m.minCellClass}">${fmtVal(m.columns.min_value)}</td>`;
                row += `<td class="${m.maxCellClass}">${fmtVal(m.columns.max_value)}</td>`;
                row += `<td>${m.columns.interval}s</td>`;
                row += `<td class="db-content-separator">${m.metadata.timestamp_age || '-'}</td>`;
                row += `<td class="${m.isOverdue ? 'overdue-text' : ''}">${m.nextUpdateText}</td>`;
                row += `<td>${m.metadata.data_span || '-'}</td>`;
                row += `<td>${m.metadata.line_count || '-'}</td>`;
                row += `<td class="metric-delete" data-agent="${m.agentId}" data-metric="${m.metricName}" title="Delete metric">×</td>`;
                row += `</tr>`;
                return row;
            };

            const tableHeader = `<thead><tr>
                <td>NAME</td><td>TIMESTAMP</td><td>REAL</td><td>INT</td><td>TEXT</td>
                <td>MIN</td><td>MAX</td><td>INTERVAL</td>
                <td class="db-content-separator">LAST UPDATE</td><td>NEXT UPDATE</td>
                <td>DATA SPAN</td><td># SAMPLES</td><td></td>
            </tr></thead>`;

            let html = '';

            // Update header with issues count
            const metricsHeader = document.getElementById('metrics-header');
            if (metricsHeader) {
                if (problemMetrics.length > 0) {
                    metricsHeader.innerHTML = `All Values <span class="issues-badge">⚠ ${problemMetrics.length}</span>`;
                } else {
                    metricsHeader.textContent = 'All Values';
                }
            }

            // Problem metrics (always visible)
            if (problemMetrics.length > 0) {
                html += `<div class="metrics-problems">`;
                html += `<table id="metrics-table-problems">${tableHeader}<tbody>`;
                problemMetrics.forEach(m => html += buildRow(m));
                html += '</tbody></table></div>';
            }

            // OK metrics (collapsible)
            if (okMetrics.length > 0) {
                const isExpanded = window.okMetricsExpanded || false;
                html += `<div class="metrics-ok">`;
                html += `<h4 class="metrics-ok-header" onclick="toggleOkMetrics()">✓ OK (${okMetrics.length}) <span class="expand-hint">${isExpanded ? '▼' : '▶'}</span></h4>`;
                html += `<div id="ok-metrics-content" class="${isExpanded ? '' : 'hidden-section'}">`;
                html += `<table id="metrics-table-ok">${tableHeader}<tbody>`;
                okMetrics.forEach(m => html += buildRow(m));
                html += '</tbody></table></div></div>';
            }

            const updateTable = () => {
                metricsList.innerHTML = html;
                // Attach delete handlers
                metricsList.querySelectorAll('.metric-delete').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const agentId = e.target.dataset.agent;
                        const metricName = e.target.dataset.metric;
                        if (confirm(`Delete metric "${metricName}"?`)) {
                            try {
                                const resp = await fetch(`/api/agents/${agentId}/metrics/${metricName}`, { method: 'DELETE' });
                                const result = await resp.json();
                                if (result.success) {
                                    addLog(`deleted ${metricName}`, 'success');
                                    loadMetrics(agentId);
                                } else {
                                    addLog(`delete failed: ${result.message}`, 'error');
                                }
                            } catch (err) {
                                addLog(`delete error: ${err.message}`, 'error');
                            }
                        }
                    });
                });
            };

            if (window.globalClock.pendingDomUpdates) {
                window.globalClock.pendingDomUpdates.push(updateTable);
            } else {
                updateTable();
            }
        } catch (error) {
            console.error('Error loading metrics:', error);
            const metricsList = document.getElementById('metrics-list');
            if (metricsList) metricsList.innerHTML = '<span class="error-text">Failed to load metrics</span>';
        }
    }

    async function loadSystemStatus(entityId, entityType) {
        try {
            const [entitiesResponse, stalenessResponse] = await Promise.all([
                fetch('/api/entities'),
                fetch('/api/messages/staleness?hours=336')
            ]);
            if (!entitiesResponse.ok) throw new Error(`HTTP ${entitiesResponse.status}`);

            const data = await entitiesResponse.json();
            const entity = data.entities.find(e => e.id === entityId);
            if (!entity) return;

            const warnings = [];
            if (!entity.has_mqtt_user) warnings.push('MQTT USER MISSING');
            if (entity.type === 'agent' && !entity.has_table) warnings.push('SQL TABLES MISSING');

            if (stalenessResponse.ok) {
                const staleness = await stalenessResponse.json();
                const staleAgent = (staleness.per_agent || []).find(a => a.agent_id === entityId);
                if (staleAgent && staleAgent.is_stale) {
                    warnings.push('MAIL STALE > 14D');
                }
            }

            const warningsEl = document.getElementById('status-warnings');
            if (warningsEl) warningsEl.textContent = warnings.join(' · ');
        } catch (error) {
            console.error('Error loading system status:', error);
        }
    }
</script>
