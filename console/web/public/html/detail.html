<!--
Detail view panel component with Chart.js line charts for CPU, memory, and disk metrics.
Reads agent data from table row data attributes. Functions: openDetailView(), closeDetailView(), renderCharts().
-->
<script>
    let detailViewOpen = false;
    let detailRefreshInterval = null;

    function openDetailView() {
        detailViewOpen = true;
        const agent = getSelectedAgent();
        if (!agent) {
            console.error('No agent selected');
            return;
        }

        try {
            const panel = document.getElementById('detail-panel');
            panel.classList.remove('detail-panel-empty');

            // Get current values from history
            const currentCpu = agent.cpuHistory && agent.cpuHistory.length > 0 ? agent.cpuHistory[agent.cpuHistory.length - 1].value : 0;
            const currentMem = agent.memHistory && agent.memHistory.length > 0 ? agent.memHistory[agent.memHistory.length - 1].value : 0;
            const currentDisk = agent.diskHistory && agent.diskHistory.length > 0 ? agent.diskHistory[agent.diskHistory.length - 1].value : 0;

            // Calculate averages
            const cpuValues = agent.cpuHistory && agent.cpuHistory.length > 0 ? agent.cpuHistory.map(h => h.value) : [];
            const memValues = agent.memHistory && agent.memHistory.length > 0 ? agent.memHistory.map(h => h.value) : [];
            const diskValues = agent.diskHistory && agent.diskHistory.length > 0 ? agent.diskHistory.map(h => h.value) : [];
            const avgCpu = cpuValues.length > 0 ? (cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length) : 0;
            const avgMem = memValues.length > 0 ? (memValues.reduce((a, b) => a + b, 0) / memValues.length) : 0;

            // Generate sparklines (last 8 values)
            const cpuSparkline = generateSparkline(cpuValues.slice(-8));
            const memSparkline = generateSparkline(memValues.slice(-8));
            const diskSparkline = generateSparkline(diskValues.slice(-8));

        panel.innerHTML = `
            <div class="detail-header">
                <h2><span class="status-dot ${agent.status}"></span>${agent.hostname || agent.id} <span class="detail-id">${agent.id}</span></h2>
                <span class="detail-status">${agent.status} · ${agent.age}</span>
            </div>
            <div class="detail-content">
                <div class="detail-stats">
                    <div class="stat-column">
                        <div class="stat-line">
                            <span class="stat-label">CPU</span>
                            <span class="stat-value">${currentCpu.toFixed(1)}%</span>
                            <span class="sparkline">${cpuSparkline}</span>
                            <span class="stat-extra">avg ${avgCpu.toFixed(1)}%</span>
                        </div>
                        <div class="stat-line">
                            <span class="stat-label">MEM</span>
                            <span class="stat-value">${currentMem.toFixed(1)}%</span>
                            <span class="sparkline">${memSparkline}</span>
                            <span class="stat-extra">avg ${avgMem.toFixed(1)}%</span>
                        </div>
                        <div class="stat-line">
                            <span class="stat-label">DISK</span>
                            <span class="stat-value">${currentDisk.toFixed(1)}%</span>
                            <span class="sparkline">${diskSparkline}</span>
                            <span class="stat-extra">free ${(100 - currentDisk).toFixed(1)}%</span>
                        </div>
                    </div>
                    <div class="stat-column">
                        <div class="stat-line">
                            <span class="stat-label">UPTIME</span>
                            <span class="stat-value">${agent.age}</span>
                        </div>
                        <div class="stat-line">
                            <span class="stat-label">CONNECTION</span>
                            <span class="stat-value">ssh</span>
                            <span class="stat-extra">authenticated</span>
                        </div>
                        <div class="stat-line">
                            <span class="stat-label">SAMPLES</span>
                            <span class="stat-value">${agent.cpuHistory ? agent.cpuHistory.length : 0}</span>
                        </div>
                    </div>
                </div>

                <div class="charts-grid">
                    <div class="chart-section">
                        <h3>cpu history</h3>
                        <canvas id="cpu-chart"></canvas>
                    </div>
                    <div class="chart-section">
                        <h3>memory history</h3>
                        <canvas id="mem-chart"></canvas>
                    </div>
                    <div class="chart-section">
                        <h3>disk history</h3>
                        <canvas id="disk-chart"></canvas>
                    </div>
                </div>

                <div class="tsv-files-section">
                    <h3>All Values</h3>
                    <div id="tsv-files-list" class="tsv-files-list">
                        <span class="loading-text">Loading TSV files...</span>
                    </div>
                </div>
            </div>
        `;

            renderCharts(agent);
            loadTsvFiles(agent.id);

            // Start auto-refresh if not already running
            if (!detailRefreshInterval) {
                detailRefreshInterval = setInterval(() => {
                    if (detailViewOpen) {
                        refreshDetailView();
                    }
                }, 1000);
            }
        } catch (error) {
            console.error('Error opening detail view:', error);
            addLog(`error opening detail: ${error.message}`, 'error');
        }
    }

    function refreshDetailView() {
        if (!detailViewOpen) return;

        const agent = getSelectedAgent();
        if (!agent) return;

        try {
            // Get current values from history
            const currentCpu = agent.cpuHistory && agent.cpuHistory.length > 0 ? agent.cpuHistory[agent.cpuHistory.length - 1].value : 0;
            const currentMem = agent.memHistory && agent.memHistory.length > 0 ? agent.memHistory[agent.memHistory.length - 1].value : 0;
            const currentDisk = agent.diskHistory && agent.diskHistory.length > 0 ? agent.diskHistory[agent.diskHistory.length - 1].value : 0;

            // Calculate averages
            const cpuValues = agent.cpuHistory && agent.cpuHistory.length > 0 ? agent.cpuHistory.map(h => h.value) : [];
            const memValues = agent.memHistory && agent.memHistory.length > 0 ? agent.memHistory.map(h => h.value) : [];
            const avgCpu = cpuValues.length > 0 ? (cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length) : 0;
            const avgMem = memValues.length > 0 ? (memValues.reduce((a, b) => a + b, 0) / memValues.length) : 0;

            // Generate sparklines
            const cpuSparkline = generateSparkline(cpuValues.slice(-8));
            const memSparkline = generateSparkline(memValues.slice(-8));
            const diskValues = agent.diskHistory && agent.diskHistory.length > 0 ? agent.diskHistory.map(h => h.value) : [];
            const diskSparkline = generateSparkline(diskValues.slice(-8));

            // Update stat values only (not the whole panel to avoid re-rendering charts)
            const statLines = document.querySelectorAll('.stat-line');
            if (statLines.length >= 3) {
                statLines[0].querySelector('.stat-value').textContent = `${currentCpu.toFixed(1)}%`;
                statLines[0].querySelector('.sparkline').textContent = cpuSparkline;
                statLines[0].querySelector('.stat-extra').textContent = `avg ${avgCpu.toFixed(1)}%`;

                statLines[1].querySelector('.stat-value').textContent = `${currentMem.toFixed(1)}%`;
                statLines[1].querySelector('.sparkline').textContent = memSparkline;
                statLines[1].querySelector('.stat-extra').textContent = `avg ${avgMem.toFixed(1)}%`;

                statLines[2].querySelector('.stat-value').textContent = `${currentDisk.toFixed(1)}%`;
                statLines[2].querySelector('.sparkline').textContent = diskSparkline;
                statLines[2].querySelector('.stat-extra').textContent = `free ${(100 - currentDisk).toFixed(1)}%`;
            }

            // Update header status
            const detailStatus = document.querySelector('.detail-status');
            if (detailStatus) {
                detailStatus.textContent = `${agent.status} · ${agent.age}`;
            }

            // Update samples count
            if (statLines.length >= 6) {
                statLines[5].querySelector('.stat-value').textContent = agent.cpuHistory ? agent.cpuHistory.length : 0;
            }

            // Refresh TSV files data
            loadTsvFiles(agent.id);
        } catch (error) {
            console.error('Error refreshing detail view:', error);
        }
    }

    function closeDetailView() {
        detailViewOpen = false;
        if (detailRefreshInterval) {
            clearInterval(detailRefreshInterval);
            detailRefreshInterval = null;
        }
        const panel = document.getElementById('detail-panel');
        panel.classList.add('detail-panel-empty');
        panel.innerHTML = '<span class="detail-placeholder">← Select an agent and press <kbd>Enter</kbd></span>';
    }

    function renderCharts(agent) {
        if (agent.cpuHistory && agent.cpuHistory.length > 0) {
            renderChart('cpu-chart', 'CPU Usage', agent.cpuHistory, '#a6e3a1', '%');
        }
        if (agent.memHistory && agent.memHistory.length > 0) {
            renderChart('mem-chart', 'Memory Usage', agent.memHistory, '#89b4fa', '%');
        }
        if (agent.diskHistory && agent.diskHistory.length > 0) {
            renderChart('disk-chart', 'Disk Usage', agent.diskHistory, '#f9e2af', '%');
        }
    }

    function renderChart(canvasId, label, data, color, suffix = '') {
        const ctx = document.getElementById(canvasId);
        if (!ctx) return;

        // Extract timestamps and values
        const timestamps = data.map(d => d.timestamp * 1000); // Convert to milliseconds
        const values = data.map(d => d.value);

        // Create time labels
        const labels = timestamps.map(ts => {
            const date = new Date(ts);
            return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
        });

        new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: values,
                    borderColor: color,
                    backgroundColor: 'transparent',
                    borderWidth: 1.5,
                    tension: 0,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.9)',
                        titleColor: '#cdd6f4',
                        bodyColor: '#cdd6f4',
                        borderColor: '#45475a',
                        borderWidth: 1,
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                return context[0].label;
                            },
                            label: function(context) {
                                return context.parsed.y.toFixed(1) + suffix;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            color: '#6c7086',
                            stepSize: 25,
                            callback: function(value) {
                                return value + suffix;
                            }
                        },
                        grid: {
                            color: '#313244',
                            drawTicks: false
                        }
                    },
                    x: {
                        ticks: {
                            color: '#6c7086',
                            maxTicksLimit: 10,
                            maxRotation: 0,
                            minRotation: 0
                        },
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
    }

    function generateSparkline(values) {
        if (!values || values.length === 0) return '';

        const blocks = ['▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'];
        const minVal = Math.min(...values);
        const maxVal = Math.max(...values);
        const range = maxVal - minVal || 1;

        return values.map(val => {
            const normalized = (val - minVal) / range;
            const index = Math.floor(normalized * (blocks.length - 1));
            return blocks[index];
        }).join('');
    }

    function formatTimestampAge(timestamp) {
        if (!timestamp || timestamp === '-') return '-';

        const now = Math.floor(Date.now() / 1000);
        const seconds = now - parseInt(timestamp);

        if (seconds < 0) return 'just now';
        if (seconds < 60) return `${seconds}s ago`;

        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m ago`;

        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;

        const days = Math.floor(hours / 24);
        return `${days}d ago`;
    }

    async function loadTsvFiles(agentId) {
        try {
            const response = await fetch(`/api/agents/${agentId}/tsv`);
            if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
            }

            const data = await response.json();
            const tsvFilesList = document.getElementById('tsv-files-list');

            if (!data.tsv_files || data.tsv_files.length === 0) {
                tsvFilesList.innerHTML = '<span class="no-data-text">No TSV files found</span>';
                return;
            }

            // Build the TSV files table
            let html = '<table id="tsv-table"><thead><tr>';
            html += '<td>NAME</td>';
            html += '<td>TIMESTAMP</td>';
            html += '<td>VALUE</td>';
            html += '<td>CYCLE (S)</td>';
            html += '<td># VALUES</td>';
            html += '</tr></thead><tbody>';

            data.tsv_files.forEach(file => {
                // Parse the TSV line: timestamp interval value
                const parts = file.lastLine.split(/\s+/);
                const timestamp = parts[0] || '-';
                const interval = parts[1] || '-';
                const value = parts[2] || '-';
                const lineCount = file.line_count || '-';
                const timestampAge = formatTimestampAge(timestamp);

                html += `<tr>`;
                html += `<td class="tsv-filename">${file.filename}</td>`;
                html += `<td>${timestampAge}</td>`;
                html += `<td>${value}</td>`;
                html += `<td>${interval}</td>`;
                html += `<td>${lineCount}</td>`;
                html += `</tr>`;
            });

            html += '</tbody></table>';
            tsvFilesList.innerHTML = html;
        } catch (error) {
            console.error('Error loading TSV files:', error);
            const tsvFilesList = document.getElementById('tsv-files-list');
            tsvFilesList.innerHTML = '<span class="error-text">Failed to load TSV files</span>';
        }
    }
</script>
