<!--
Agents table component with live HTML fragment updates via /api/agents/table.
Fetches server-rendered rows every 1s. Provides row selection, navigation functions, and getSelectedAgent().
-->
<div class="agents-section">
    <table id="agents-table">
        <thead>
            <tr>
                <td>hostname</td>
                <td></td>
                <td>cpu</td>
                <td>mem</td>
                <td>disk</td>
            </tr>
        </thead>
        <tbody id="agents-tbody">
            <tr>
                <td colspan="5" class="no-data">loading...</td>
            </tr>
        </tbody>
    </table>
</div>

<script>
    // UI state managed in window.app (index.html)

    // Store unread message counts
    window.app.messages = window.app.messages || { unreadCounts: {} };

    // Fetch unread message counts
    async function fetchUnreadCounts() {
        try {
            const response = await fetch('/api/messages/unread-counts');
            if (response.ok) {
                const data = await response.json();
                window.app.messages.unreadCounts = data.counts || {};
            }
        } catch (e) {
            // Silently fail - messages feature might not be available
        }
    }

    async function fetchAgents() {
        // Also fetch unread counts
        await fetchUnreadCounts();
        try {
            const response = await fetch('/api/entities');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            const tbody = document.getElementById('agents-tbody');

            // Render entities
            if (data.entities && data.entities.length > 0) {
                // Sort: regular agents alphabetically, then mail-only, then invites at bottom
                const sortedEntities = [...data.entities].sort((a, b) => {
                    // Get group: 0=regular agent, 1=mail-only, 2=invite
                    const getGroup = (e) => {
                        if (e.type === 'invite') return 2;
                        if (e.mail_only) return 1;
                        return 0;
                    };
                    const aGroup = getGroup(a);
                    const bGroup = getGroup(b);

                    // Sort by group first
                    if (aGroup !== bGroup) return aGroup - bGroup;

                    // Within same group, sort alphabetically by display name or hostname
                    const aName = (a.display_name || a.hostname || a.id).toLowerCase();
                    const bName = (b.display_name || b.hostname || b.id).toLowerCase();
                    return aName.localeCompare(bName);
                });

                let html = '';

                sortedEntities.forEach((entity, i) => {
                    const index = i;
                    const selected = index === 0 ? 'selected' : '';
                    const validClass = entity.valid ? '' : 'entity-invalid';

                    if (entity.type === 'invite') {
                        // Render invite row
                        const statusDot = entity.valid ? 'online' : 'offline';
                        html += `<tr class="agent-row entity-invite ${selected} ${validClass}" data-index="${index}" data-entity-id="${entity.id}" data-entity-type="invite" data-valid="${entity.valid}">`;
                        html += `<td><span class="status-dot ${statusDot}" title="${entity.valid ? 'active invite' : 'invalid'}"></span>${entity.id} â—·</td>`;
                        html += `<td colspan="4"></td>`;
                        html += `</tr>`;
                    } else if (entity.mail_only) {
                        // Render mail-only host row (no agent installed, only receives mail)
                        const agentUnread = window.app.messages.unreadCounts[entity.id] || 0;
                        const unreadBadge = agentUnread > 0 ? `<span class="unread-badge-inline" title="${agentUnread} unread">\u2709${agentUnread}</span>` : '';
                        const displayName = entity.display_name || entity.id;

                        html += `<tr class="agent-row ${selected}" data-index="${index}" data-entity-id="${entity.id}" data-entity-type="agent" data-hostname="${displayName}" data-status="mail-only" data-valid="true" data-mail-only="true" data-display-name="${entity.display_name || ''}" data-original-hostname="">`;
                        html += `<td title="ID: ${entity.id} (mail only)"><span class="status-dot warning" title="mail-only"></span>${displayName}${unreadBadge}</td>`;
                        html += `<td colspan="4" class="mail-only-label">mail only</td>`;
                        html += `</tr>`;
                    } else {
                        // Render agent row
                        // Status: use backend status, but also check failed_collectors and outdated version
                        let statusDot = entity.status || 'offline';
                        const latestVersion = window.app?.data?.latestVersion;
                        const agentVersion = entity.agent_version || '';
                        const isOutdated = latestVersion && agentVersion &&
                            agentVersion !== latestVersion && !agentVersion.startsWith(latestVersion);
                        if (statusDot === 'online' && (entity.failed_collectors > 0 || isOutdated)) {
                            statusDot = 'degraded';
                        }
                        const originalHostname = entity.hostname || entity.id;
                        const displayName = entity.display_name || originalHostname;
                        const cpu = entity.cpu || 0;
                        const memory = entity.memory || 0;
                        const disk = entity.disk || 0;
                        const cpuSparkline = entity.cpuSparkline || '';
                        const cpuHistory = JSON.stringify(entity.cpuHistory || []);
                        const memHistory = JSON.stringify(entity.memHistory || []);
                        const diskHistory = JSON.stringify(entity.diskHistory || []);
                        const pendingInvite = entity.pending_invite ? JSON.stringify(entity.pending_invite).replace(/'/g, '&#39;') : '';

                        html += `<tr class="agent-row ${selected} ${validClass}" data-index="${index}" data-entity-id="${entity.id}" data-entity-type="agent" data-hostname="${displayName}" data-status="${statusDot}" data-valid="${entity.valid}" data-age="${entity.age || 0}" data-uptime="${entity.uptime || ''}" data-heartbeat="${entity.heartbeat || 0}" data-cpu-history='${cpuHistory}' data-mem-history='${memHistory}' data-disk-history='${diskHistory}' data-pending-invite='${pendingInvite}' data-display-name="${entity.display_name || ''}" data-original-hostname="${originalHostname}">`;
                        const pendingSymbol = entity.valid ? '' : ' (pending)';
                        // Check for unread messages for this agent
                        const agentUnread = window.app.messages.unreadCounts[entity.id] || 0;
                        const unreadBadge = agentUnread > 0 ? `<span class="unread-badge-inline" title="${agentUnread} unread">\u2709${agentUnread}</span>` : '';

                        html += `<td title="ID: ${entity.id}"><span class="status-dot ${statusDot}" title="${statusDot}"></span>${displayName}${pendingSymbol}${unreadBadge}</td>`;
                        html += `<td><span class="sparkline">${cpuSparkline}</span></td>`;
                        html += `<td>${cpu.toFixed(0)}%</td>`;
                        html += `<td>${memory.toFixed(0)}%</td>`;
                        html += `<td>${disk.toFixed(0)}%</td>`;
                        html += `</tr>`;
                    }
                });

                // Queue DOM update (wait for all data to load)
                if (window.globalClock.pendingDomUpdates) {
                    window.globalClock.pendingDomUpdates.push(() => {
                        tbody.innerHTML = html;
                    });
                } else {
                    // Fallback if not called from globalClock
                    tbody.innerHTML = html;
                }
            } else {
                const noDataHtml = `<tr><td colspan="5" class="no-data">no agents connected</td></tr>`;
                if (window.globalClock.pendingDomUpdates) {
                    window.globalClock.pendingDomUpdates.push(() => {
                        tbody.innerHTML = noDataHtml;
                    });
                } else {
                    tbody.innerHTML = noDataHtml;
                }
            }

            // Queue post-render actions (after DOM update)
            const postRender = () => {
                attachRowHandlers();

                // Restore highlight after content refresh
                const rows = tbody.querySelectorAll('.agent-row');
                if (rows.length > 0) {
                    // On first load, try to restore agent from URL
                    if (window.app.data.isFirstLoad && window.app.data.initialAgentId) {
                        const restored = selectAgentById(window.app.data.initialAgentId);
                        if (!restored) {
                            // Agent not found, fall back to first
                            selectRow(0);
                        }
                    } else {
                        // Clamp selectedRow to valid range
                        if (window.app.ui.selectedRow >= rows.length) {
                            window.app.ui.selectedRow = rows.length - 1;
                        }
                        selectRow(window.app.ui.selectedRow);
                    }
                }

                const currentCount = rows.length;
                if (window.app.data.previousAgentCount !== 0 && currentCount > window.app.data.previousAgentCount) {
                    addLog(`entity added (total: ${currentCount})`, 'success');
                } else if (window.app.data.previousAgentCount !== 0 && currentCount < window.app.data.previousAgentCount) {
                    addLog(`entity removed (total: ${currentCount})`, 'error');
                }
                window.app.data.previousAgentCount = currentCount;

                // Auto-open detail view on first load if entities exist
                if (window.app.data.isFirstLoad && currentCount > 0) {
                    window.app.data.isFirstLoad = false;
                    setTimeout(() => {
                        openDetailView();
                    }, 100);
                }
            };

            // Queue or run immediately
            if (window.globalClock.pendingDomUpdates) {
                window.globalClock.pendingDomUpdates.push(postRender);
            } else {
                postRender();
            }

            // Detail view now refreshes on globalClock (no cascade needed)

        } catch (error) {
            console.error('Error:', error);
            const tbody = document.getElementById('agents-tbody');
            tbody.innerHTML = `<tr><td colspan="5" class="no-data">error: ${error.message}</td></tr>`;
            addLog(`error fetching entities: ${error.message}`, 'error');
        }
    }

    function attachRowHandlers() {
        const rows = document.querySelectorAll('.agent-row');
        rows.forEach(row => {
            row.addEventListener('click', () => {
                const index = parseInt(row.dataset.index);
                selectRow(index);

                // If it's an invite, copy URL on click
                if (row.dataset.entityType === 'invite') {
                    copyInviteUrl(row.dataset.entityId);
                } else {
                    // For agents, open detail view
                    openDetailView();
                }
            });
        });
    }

    // Copy agent email address
    async function copyAgentEmail(agentId) {
        try {
            const response = await fetch(`/api/agents/${agentId}/email`);
            const data = await response.json();
            await copyText(data.email, `Email copied: ${data.email}`);
        } catch (error) {
            addLog(`Error copying email: ${error.message}`, 'error');
        }
    }

    function selectRow(index) {
        const rows = document.querySelectorAll('.agent-row');
        if (index < 0 || index >= rows.length) return;

        window.app.ui.selectedRow = index;

        rows.forEach((row, i) => {
            if (i === index) {
                row.classList.add('selected');
            } else {
                row.classList.remove('selected');
            }
        });
    }

    function moveSelection(direction) {
        const rows = document.querySelectorAll('.agent-row');
        if (rows.length === 0) return;

        const newIndex = window.app.ui.selectedRow + direction;
        if (newIndex >= 0 && newIndex < rows.length) {
            selectRow(newIndex);
            const row = rows[newIndex];
            if (row) {
                row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Auto-open detail view if not already open, or refresh if open
            if (typeof openDetailView === 'function') {
                openDetailView();
            }
        }
    }

    function getSelectedAgent() {
        const row = document.querySelector(`.agent-row[data-index="${window.app.ui.selectedRow}"]`);
        if (!row) {
            console.error('No row found for selected index:', window.app.ui.selectedRow);
            return null;
        }

        try {
            const data = {
                id: row.dataset.entityId || row.dataset.agentId,
                type: row.dataset.entityType || 'agent',
                valid: row.dataset.valid === 'true',
                hostname: row.dataset.hostname || '',
                original_hostname: row.dataset.originalHostname || '',
                status: row.dataset.status,
                age: row.dataset.age,
                uptime: row.dataset.uptime || '',
                heartbeat: parseInt(row.dataset.heartbeat) || 0,
                cpuHistory: row.dataset.cpuHistory ? JSON.parse(row.dataset.cpuHistory) : [],
                memHistory: row.dataset.memHistory ? JSON.parse(row.dataset.memHistory) : [],
                diskHistory: row.dataset.diskHistory ? JSON.parse(row.dataset.diskHistory) : [],
                mail_only: row.dataset.mailOnly === 'true',
                display_name: row.dataset.displayName || ''
            };

            // Add pending invite if exists
            if (row.dataset.pendingInvite) {
                data.pending_invite = JSON.parse(row.dataset.pendingInvite);
            }

            return data;
        } catch (error) {
            console.error('Error parsing entity data:', error);
            return null;
        }
    }

    async function copyInviteUrl(inviteId) {
        try {
            const response = await fetch(`/api/invites/${inviteId}/url`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            if (data.success) {
                // Use shared utility to copy
                const copied = await copyText(data.install_command, 'invite command copied to clipboard');
                if (!copied) {
                    // Fallback: show in log if clipboard fails
                    addLog(`invite: ${data.install_command}`, 'info');
                }
            } else {
                addLog(`copy failed: ${data.error}`, 'error');
            }
        } catch (error) {
            console.error('Error:', error);
            addLog(`error copying invite: ${error.message}`, 'error');
        }
    }

    // Get agent ID from URL hash
    function getAgentIdFromUrl() {
        const hash = window.location.hash;
        if (hash.startsWith('#agent=')) {
            return hash.substring(7);
        }
        return null;
    }

    // Set agent ID in URL hash
    function setAgentIdInUrl(agentId) {
        if (agentId) {
            const newUrl = window.location.pathname + window.location.search + '#agent=' + agentId;
            window.history.replaceState(null, '', newUrl);
        }
    }

    // Find and select agent by ID
    function selectAgentById(agentId) {
        const rows = document.querySelectorAll('.agent-row');
        for (let i = 0; i < rows.length; i++) {
            if (rows[i].dataset.entityId === agentId) {
                selectRow(i);
                return true;
            }
        }
        return false;
    }

    // Override selectRow to update URL
    const originalSelectRow = selectRow;
    selectRow = function(index) {
        originalSelectRow(index);
        // Update URL with selected agent ID
        const row = document.querySelector(`.agent-row[data-index="${index}"]`);
        if (row && row.dataset.entityId) {
            setAgentIdInUrl(row.dataset.entityId);
        }
    };

    // Initialize
    addLog('console started', 'success');
    addLog('loading agents...', 'info');

    // Store the agent ID from URL to restore after first load
    window.app.data.initialAgentId = getAgentIdFromUrl();

    fetchAgents();
    window.globalClock.register(fetchAgents);
</script>
