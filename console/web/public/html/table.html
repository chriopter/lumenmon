<!--
Agents table component with live HTML fragment updates via /api/agents/table.
Fetches server-rendered rows every 1s. Provides row selection, navigation functions, and getSelectedAgent().
-->
<div class="agents-section">
    <table id="agents-table">
        <thead>
            <tr>
                <td>hostname</td>
                <td></td>
                <td>cpu</td>
                <td>mem</td>
                <td>disk</td>
            </tr>
        </thead>
        <tbody id="agents-tbody">
            <tr>
                <td colspan="5" class="no-data">loading...</td>
            </tr>
        </tbody>
    </table>
</div>

<script>
    // UI state managed in window.app (index.html)

    // Store unread message counts
    window.app.messages = window.app.messages || { unreadCounts: {} };

    // Track if dragging is in progress (to pause table updates)
    window.app.isDragging = false;

    // Fetch unread message counts
    async function fetchUnreadCounts() {
        try {
            const response = await fetch('/api/messages/unread-counts');
            if (response.ok) {
                const data = await response.json();
                window.app.messages.unreadCounts = data.counts || {};
            }
        } catch (e) {
            // Silently fail - messages feature might not be available
        }
    }

    async function fetchAgents() {
        // Also fetch unread counts
        await fetchUnreadCounts();
        try {
            const response = await fetch('/api/entities');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            const tbody = document.getElementById('agents-tbody');

            // Render entities
            if (data.entities && data.entities.length > 0) {
                // Sort: by group (alphabetically), then regular agents, mail-only, invites at bottom
                const sortedEntities = [...data.entities].sort((a, b) => {
                    // Get type order: 0=regular agent, 1=mail-only, 2=invite
                    const getTypeOrder = (e) => {
                        if (e.type === 'invite') return 2;
                        if (e.mail_only) return 1;
                        return 0;
                    };

                    const aTypeOrder = getTypeOrder(a);
                    const bTypeOrder = getTypeOrder(b);

                    // Invites always at the very bottom
                    if (aTypeOrder === 2 && bTypeOrder !== 2) return 1;
                    if (bTypeOrder === 2 && aTypeOrder !== 2) return -1;
                    if (aTypeOrder === 2 && bTypeOrder === 2) return 0;

                    // Sort by group first (null/undefined = ungrouped, goes last)
                    const aGroup = a.group || '\xff';
                    const bGroup = b.group || '\xff';
                    if (aGroup !== bGroup) return aGroup.localeCompare(bGroup);

                    // Within same group, mail-only goes after regular agents
                    if (aTypeOrder !== bTypeOrder) return aTypeOrder - bTypeOrder;

                    // Within same group and type, sort alphabetically by display name or hostname
                    const aName = (a.display_name || a.hostname || a.id).toLowerCase();
                    const bName = (b.display_name || b.hostname || b.id).toLowerCase();
                    return aName.localeCompare(bName);
                });

                let html = '';
                let currentGroup = null;
                let rowIndex = 0;

                sortedEntities.forEach((entity, i) => {
                    // Insert group header if group changed (skip for invites)
                    if (entity.type !== 'invite') {
                        const entityGroup = entity.group || null;
                        if (entityGroup !== currentGroup) {
                            currentGroup = entityGroup;
                            if (entityGroup) {
                                html += `<tr class="group-header" data-group="${entityGroup}">`;
                                html += `<td colspan="5"><span class="group-name" contenteditable="true">${entityGroup}</span></td>`;
                                html += `</tr>`;
                            } else if (i > 0) {
                                // Empty separator row if there were grouped agents before
                                const hasGroupedBefore = sortedEntities.slice(0, i).some(e => e.group && e.type !== 'invite');
                                if (hasGroupedBefore) {
                                    html += `<tr class="group-header ungrouped-header" data-group="">`;
                                    html += `<td colspan="5"></td>`;
                                    html += `</tr>`;
                                }
                            }
                        }
                    }

                    const index = rowIndex++;
                    const selected = index === 0 ? 'selected' : '';
                    const validClass = entity.valid ? '' : 'entity-invalid';
                    const groupAttr = entity.group ? `data-group="${entity.group}"` : '';

                    if (entity.type === 'invite') {
                        // Render invite row
                        const statusDot = entity.valid ? 'online' : 'offline';
                        html += `<tr class="agent-row entity-invite ${selected} ${validClass}" data-index="${index}" data-entity-id="${entity.id}" data-entity-type="invite" data-valid="${entity.valid}">`;
                        html += `<td><span class="status-dot ${statusDot}" title="${entity.valid ? 'active invite' : 'invalid'}"></span>${entity.id} â—·</td>`;
                        html += `<td colspan="4"></td>`;
                        html += `</tr>`;
                    } else if (entity.mail_only) {
                        // Render mail-only host row (no agent installed, only receives mail)
                        const agentUnread = window.app.messages.unreadCounts[entity.id] || 0;
                        const unreadBadge = agentUnread > 0 ? `<span class="unread-badge-inline" title="${agentUnread} unread">\u2709${agentUnread}</span>` : '';
                        const displayName = entity.display_name || entity.id;

                        html += `<tr class="agent-row ${selected}" data-index="${index}" data-entity-id="${entity.id}" data-entity-type="agent" data-hostname="${displayName}" data-status="mail-only" data-valid="true" data-mail-only="true" data-display-name="${entity.display_name || ''}" data-original-hostname="" ${groupAttr} draggable="true">`;
                        html += `<td title="ID: ${entity.id} (mail only)"><span class="status-dot warning" title="mail-only"></span>${displayName}${unreadBadge}</td>`;
                        html += `<td colspan="4" class="mail-only-label">mail only</td>`;
                        html += `</tr>`;
                    } else {
                        // Render agent row
                        // Status: use backend status, but also check failed_collectors and outdated version
                        let statusDot = entity.status || 'offline';
                        const latestVersion = window.app?.data?.latestVersion;
                        const agentVersion = entity.agent_version || '';
                        const isOutdated = latestVersion && agentVersion &&
                            agentVersion !== latestVersion && !agentVersion.startsWith(latestVersion);
                        if (statusDot === 'online' && (entity.failed_collectors > 0 || isOutdated)) {
                            statusDot = 'degraded';
                        }
                        const originalHostname = entity.original_hostname || entity.hostname || entity.id;
                        const displayName = entity.display_name || originalHostname;
                        const cpu = entity.cpu || 0;
                        const memory = entity.memory || 0;
                        const disk = entity.disk || 0;
                        const cpuSparkline = entity.cpuSparkline || '';
                        const cpuHistory = JSON.stringify(entity.cpuHistory || []);
                        const memHistory = JSON.stringify(entity.memHistory || []);
                        const diskHistory = JSON.stringify(entity.diskHistory || []);
                        const pendingInvite = entity.pending_invite ? JSON.stringify(entity.pending_invite).replace(/'/g, '&#39;') : '';

                        html += `<tr class="agent-row ${selected} ${validClass}" data-index="${index}" data-entity-id="${entity.id}" data-entity-type="agent" data-hostname="${displayName}" data-status="${statusDot}" data-valid="${entity.valid}" data-age="${entity.age || 0}" data-uptime="${entity.uptime || ''}" data-heartbeat="${entity.heartbeat || 0}" data-cpu-history='${cpuHistory}' data-mem-history='${memHistory}' data-disk-history='${diskHistory}' data-pending-invite='${pendingInvite}' data-display-name="${entity.display_name || ''}" data-original-hostname="${originalHostname}" ${groupAttr} draggable="true">`;
                        const pendingSymbol = entity.valid ? '' : ' (pending)';
                        // Check for unread messages for this agent
                        const agentUnread = window.app.messages.unreadCounts[entity.id] || 0;
                        const unreadBadge = agentUnread > 0 ? `<span class="unread-badge-inline" title="${agentUnread} unread">\u2709${agentUnread}</span>` : '';

                        html += `<td title="ID: ${entity.id}"><span class="status-dot ${statusDot}" title="${statusDot}"></span>${displayName}${pendingSymbol}${unreadBadge}</td>`;
                        html += `<td><span class="sparkline">${cpuSparkline}</span></td>`;
                        html += `<td>${cpu.toFixed(0)}%</td>`;
                        html += `<td>${memory.toFixed(0)}%</td>`;
                        html += `<td>${disk.toFixed(0)}%</td>`;
                        html += `</tr>`;
                    }
                });

                // Queue DOM update (wait for all data to load)
                // Skip update if dragging to prevent cancelling the drag
                if (window.app.isDragging) return;
                if (window.globalClock.pendingDomUpdates) {
                    window.globalClock.pendingDomUpdates.push(() => {
                        if (!window.app.isDragging) {
                            tbody.innerHTML = html;
                        }
                    });
                } else {
                    // Fallback if not called from globalClock
                    tbody.innerHTML = html;
                }
            } else {
                if (window.app.isDragging) return;
                const noDataHtml = `<tr><td colspan="5" class="no-data">no agents connected</td></tr>`;
                if (window.globalClock.pendingDomUpdates) {
                    window.globalClock.pendingDomUpdates.push(() => {
                        if (!window.app.isDragging) {
                            tbody.innerHTML = noDataHtml;
                        }
                    });
                } else {
                    tbody.innerHTML = noDataHtml;
                }
            }

            // Queue post-render actions (after DOM update)
            const postRender = () => {
                attachRowHandlers();

                // Restore highlight after content refresh
                const rows = tbody.querySelectorAll('.agent-row');
                if (rows.length > 0) {
                    // On first load, try to restore agent from URL
                    if (window.app.data.isFirstLoad && window.app.data.initialAgentId) {
                        const restored = selectAgentById(window.app.data.initialAgentId);
                        if (!restored) {
                            // Agent not found, fall back to first
                            selectRow(0);
                        }
                    } else {
                        // Clamp selectedRow to valid range
                        if (window.app.ui.selectedRow >= rows.length) {
                            window.app.ui.selectedRow = rows.length - 1;
                        }
                        selectRow(window.app.ui.selectedRow);
                    }
                }

                const currentCount = rows.length;
                if (window.app.data.previousAgentCount !== 0 && currentCount > window.app.data.previousAgentCount) {
                    addLog(`entity added (total: ${currentCount})`, 'success');
                } else if (window.app.data.previousAgentCount !== 0 && currentCount < window.app.data.previousAgentCount) {
                    addLog(`entity removed (total: ${currentCount})`, 'error');
                }
                window.app.data.previousAgentCount = currentCount;

                // Auto-open detail view on first load if entities exist
                if (window.app.data.isFirstLoad && currentCount > 0) {
                    window.app.data.isFirstLoad = false;
                    setTimeout(() => {
                        openDetailView();
                    }, 100);
                }
            };

            // Queue or run immediately
            if (window.globalClock.pendingDomUpdates) {
                window.globalClock.pendingDomUpdates.push(postRender);
            } else {
                postRender();
            }

            // Detail view now refreshes on globalClock (no cascade needed)

        } catch (error) {
            console.error('Error:', error);
            const tbody = document.getElementById('agents-tbody');
            tbody.innerHTML = `<tr><td colspan="5" class="no-data">error: ${error.message}</td></tr>`;
            addLog(`error fetching entities: ${error.message}`, 'error');
        }
    }

    function attachRowHandlers() {
        const rows = document.querySelectorAll('.agent-row');
        rows.forEach(row => {
            row.addEventListener('click', () => {
                const index = parseInt(row.dataset.index);
                selectRow(index);

                // Open detail view for all entity types
                if (row.dataset.entityType === 'invite') {
                    openDetailView();
                } else {
                    // For agents, open detail view
                    openDetailView();
                }
            });

            // Drag & drop for grouping
            row.addEventListener('dragstart', (e) => {
                window.app.isDragging = true;
                e.dataTransfer.setData('text/plain', row.dataset.entityId);
                row.classList.add('dragging');
            });

            row.addEventListener('dragend', () => {
                window.app.isDragging = false;
                row.classList.remove('dragging');
                // Remove all drag-over states
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                document.querySelectorAll('.drag-over-row').forEach(el => el.classList.remove('drag-over-row'));
            });
        });

        // Group headers as drop targets
        const groupHeaders = document.querySelectorAll('.group-header');
        groupHeaders.forEach(header => {
            header.addEventListener('dragover', (e) => {
                e.preventDefault();
                header.classList.add('drag-over');
            });

            header.addEventListener('dragleave', () => {
                header.classList.remove('drag-over');
            });

            header.addEventListener('drop', async (e) => {
                e.preventDefault();
                header.classList.remove('drag-over');
                const agentId = e.dataTransfer.getData('text/plain');
                const groupName = header.dataset.group;

                if (agentId) {
                    await setAgentGroup(agentId, groupName);
                }
            });

            // Inline editing of group name
            const groupNameEl = header.querySelector('.group-name');
            if (groupNameEl) {
                groupNameEl.addEventListener('blur', async (e) => {
                    const oldName = header.dataset.group;
                    const newName = e.target.textContent.trim();
                    if (newName && newName !== oldName) {
                        await renameGroup(oldName, newName);
                    } else if (!newName) {
                        e.target.textContent = oldName; // Restore if empty
                    }
                });

                groupNameEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.target.blur();
                    } else if (e.key === 'Escape') {
                        e.target.textContent = header.dataset.group;
                        e.target.blur();
                    }
                });
            }
        });

        // Also allow dropping on agent rows to create new groups or add to existing
        rows.forEach(row => {
            row.addEventListener('dragover', (e) => {
                e.preventDefault();
                // Show drop indicator for all agent rows (can create new group or add to existing)
                if (row.dataset.entityType === 'agent') {
                    row.classList.add('drag-over-row');
                }
            });

            row.addEventListener('dragleave', () => {
                row.classList.remove('drag-over-row');
            });

            row.addEventListener('drop', async (e) => {
                e.preventDefault();
                row.classList.remove('drag-over-row');
                const agentId = e.dataTransfer.getData('text/plain');
                const targetGroup = row.dataset.group;
                const targetAgentId = row.dataset.entityId;

                if (!agentId || agentId === targetAgentId) return;

                if (targetGroup) {
                    // Target has a group - add dragged agent to that group
                    await setAgentGroup(agentId, targetGroup);
                } else {
                    // Target is ungrouped - create new group with both agents
                    const groupName = prompt('Enter new group name:');
                    if (groupName && groupName.trim()) {
                        await setAgentGroup(targetAgentId, groupName.trim());
                        await setAgentGroup(agentId, groupName.trim());
                    }
                }
            });
        });
    }

    // Set agent group via API
    async function setAgentGroup(agentId, groupName) {
        try {
            const response = await fetch(`/api/agents/${agentId}/group`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ group: groupName || '' })
            });
            if (response.ok) {
                addLog(`moved ${agentId.substring(0, 10)}... to ${groupName || 'ungrouped'}`, 'success');
                // Refresh immediately
                fetchAgents();
            } else {
                addLog(`failed to update group`, 'error');
            }
        } catch (error) {
            addLog(`error: ${error.message}`, 'error');
        }
    }

    // Rename group for all agents in it
    async function renameGroup(oldName, newName) {
        try {
            // Get all agents in the old group
            const response = await fetch('/api/groups');
            const data = await response.json();
            const agents = data.groups[oldName] || [];

            // Update each agent to new group name
            for (const agentId of agents) {
                await fetch(`/api/agents/${agentId}/group`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ group: newName })
                });
            }

            addLog(`renamed group "${oldName}" to "${newName}"`, 'success');
            fetchAgents();
        } catch (error) {
            addLog(`error renaming group: ${error.message}`, 'error');
        }
    }

    // Create new group from selected agent
    async function createNewGroup(agentId) {
        const groupName = prompt('Enter group name:');
        if (groupName && groupName.trim()) {
            await setAgentGroup(agentId, groupName.trim());
        }
    }

    // Copy agent email address
    async function copyAgentEmail(agentId) {
        try {
            const response = await fetch(`/api/agents/${agentId}/email`);
            const data = await response.json();
            await copyText(data.email, `Email copied: ${data.email}`);
        } catch (error) {
            addLog(`Error copying email: ${error.message}`, 'error');
        }
    }

    function selectRow(index) {
        const rows = document.querySelectorAll('.agent-row');
        if (index < 0 || index >= rows.length) return;

        window.app.ui.selectedRow = index;

        rows.forEach((row, i) => {
            if (i === index) {
                row.classList.add('selected');
            } else {
                row.classList.remove('selected');
            }
        });
    }

    function moveSelection(direction) {
        const rows = document.querySelectorAll('.agent-row');
        if (rows.length === 0) return;

        const newIndex = window.app.ui.selectedRow + direction;
        if (newIndex >= 0 && newIndex < rows.length) {
            selectRow(newIndex);
            const row = rows[newIndex];
            if (row) {
                row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Auto-open detail view if not already open, or refresh if open
            if (typeof openDetailView === 'function') {
                openDetailView();
            }
        }
    }

    function getSelectedAgent() {
        const row = document.querySelector(`.agent-row[data-index="${window.app.ui.selectedRow}"]`);
        if (!row) {
            console.error('No row found for selected index:', window.app.ui.selectedRow);
            return null;
        }

        try {
            const data = {
                id: row.dataset.entityId || row.dataset.agentId,
                type: row.dataset.entityType || 'agent',
                valid: row.dataset.valid === 'true',
                hostname: row.dataset.hostname || '',
                original_hostname: row.dataset.originalHostname || '',
                status: row.dataset.status,
                age: row.dataset.age,
                uptime: row.dataset.uptime || '',
                heartbeat: parseInt(row.dataset.heartbeat) || 0,
                cpuHistory: row.dataset.cpuHistory ? JSON.parse(row.dataset.cpuHistory) : [],
                memHistory: row.dataset.memHistory ? JSON.parse(row.dataset.memHistory) : [],
                diskHistory: row.dataset.diskHistory ? JSON.parse(row.dataset.diskHistory) : [],
                mail_only: row.dataset.mailOnly === 'true',
                display_name: row.dataset.displayName || ''
            };

            // Add pending invite if exists
            if (row.dataset.pendingInvite) {
                data.pending_invite = JSON.parse(row.dataset.pendingInvite);
            }

            return data;
        } catch (error) {
            console.error('Error parsing entity data:', error);
            return null;
        }
    }

    // Get agent ID from URL hash
    function getAgentIdFromUrl() {
        const hash = window.location.hash;
        if (hash.startsWith('#agent=')) {
            return hash.substring(7);
        }
        return null;
    }

    // Set agent ID in URL hash
    function setAgentIdInUrl(agentId) {
        if (agentId) {
            const newUrl = window.location.pathname + window.location.search + '#agent=' + agentId;
            window.history.replaceState(null, '', newUrl);
        }
    }

    // Find and select agent by ID
    function selectAgentById(agentId) {
        const rows = document.querySelectorAll('.agent-row');
        for (let i = 0; i < rows.length; i++) {
            if (rows[i].dataset.entityId === agentId) {
                selectRow(i);
                return true;
            }
        }
        return false;
    }

    // Override selectRow to update URL
    const originalSelectRow = selectRow;
    selectRow = function(index) {
        originalSelectRow(index);
        // Update URL with selected agent ID
        const row = document.querySelector(`.agent-row[data-index="${index}"]`);
        if (row && row.dataset.entityId) {
            setAgentIdInUrl(row.dataset.entityId);
        }
    };

    // Initialize
    addLog('console started', 'success');
    addLog('loading agents...', 'info');

    // Store the agent ID from URL to restore after first load
    window.app.data.initialAgentId = getAgentIdFromUrl();

    fetchAgents();
    window.globalClock.register(fetchAgents);
</script>
