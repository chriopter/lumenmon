<!--
Main dashboard shell that includes all component partials via Jinja2.
Loads CSS, Chart.js vendor library, and initializes components. Served by Flask at /.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumenmon Console</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="stylesheet" href="/css/styles.css?v={{ v }}">
    <script>
        // Global synchronized clock - waits for all async callbacks, updates UI together
        window.globalClock = {
            callbacks: [],
            ticking: false,  // Flag to prevent UI updates during data fetching
            register: function(fn) {
                if (!this.callbacks.includes(fn)) {
                    this.callbacks.push(fn);
                }
            },
            unregister: function(fn) {
                const index = this.callbacks.indexOf(fn);
                if (index > -1) {
                    this.callbacks.splice(index, 1);
                }
            },
            tick: async function() {
                // Collect DOM update functions to run after all data loads
                const domUpdates = [];
                window.globalClock.pendingDomUpdates = domUpdates;

                // Wait for all callbacks (including async API calls) to complete
                const promises = this.callbacks.map(fn => {
                    try {
                        return Promise.resolve(fn());
                    } catch (error) {
                        console.error('Global clock callback error:', error);
                        return Promise.resolve();
                    }
                });
                await Promise.all(promises);

                // All data loaded - now apply DOM updates together in one frame
                requestAnimationFrame(() => {
                    domUpdates.forEach(updateFn => {
                        try {
                            updateFn();
                        } catch (error) {
                            console.error('DOM update error:', error);
                        }
                    });
                });

                window.globalClock.pendingDomUpdates = null;
            }
        };
        // Start the global clock (fixed 1000ms interval)
        const runClock = async () => {
            while (true) {
                const start = Date.now();
                await window.globalClock.tick();
                const elapsed = Date.now() - start;
                const delay = Math.max(0, 1000 - elapsed);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        };
        runClock();

        // Centralized application state
        window.app = {
            ui: {
                selectedRow: 0,
                detailViewOpen: false,
                agentToDelete: null
            },
            data: {
                previousAgentCount: 0,
                isFirstLoad: true,
                latestVersion: null
            },
            mqtt: {
                lastMqttCount: 0,
                checkInterval: null
            },
            charts: {}
        };

        function logServerVersion(version) {
            if (!version) return;
            const message = `server version: ${version}`;

            const tryLog = () => {
                if (typeof window.addLog === 'function') {
                    window.addLog(message, 'info');
                    return true;
                }
                return false;
            };

            if (!tryLog()) {
                window.addEventListener('load', () => {
                    tryLog();
                }, { once: true });
            }
        }

        // Fetch latest version from backend (cached hourly)
        fetch('/api/version/latest')
            .then(r => r.json())
            .then(data => {
                window.app.data.latestVersion = data.version;
                logServerVersion(data.version);
            })
            .catch(() => {});

        window.refreshAlertStatus = async function() {
            const el = document.getElementById('alert-status');
            if (!el) return;
            try {
                const response = await fetch('/api/alerts/status');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();

                if (!data.configured) {
                    el.textContent = 'alerts: not configured';
                    el.className = 'status-compact warning';
                    return;
                }

                if (data.enabled && data.mode === 'active') {
                    el.textContent = 'alerts: active';
                    el.className = 'status-compact';
                    return;
                }

                el.textContent = 'alerts: webhook dry-run';
                el.className = 'status-compact warning';
            } catch (error) {
                el.textContent = 'alerts: unavailable';
                el.className = 'status-compact warning';
            }
        };

        window.addEventListener('DOMContentLoaded', () => {
            window.refreshAlertStatus();
            setInterval(window.refreshAlertStatus, 60000);
        });
    </script>
</head>
<body>
    <div class="main-content">
        <div class="left-column">
            {% include 'logger.html' %}
            {% include 'table.html' %}
        </div>
        <div class="detail-column">
            <div id="detail-panel" class="detail-panel-empty">
                <span class="detail-placeholder">← Select an agent and press <kbd>Enter</kbd></span>
            </div>
        </div>
    </div>

    <footer>
        <div class="footer-left">
            <kbd>↑/k</kbd> <kbd>↓/j</kbd> select · <kbd>enter</kbd> view · <span class="kbd-clickable" onclick="createInvite()" title="click to create invite"><kbd>i</kbd> invite</span> · <kbd>m</kbd> email · <span class="kbd-clickable" onclick="fetchAgents(); addLog('manual refresh', 'info');" title="click to refresh"><kbd>r</kbd> refresh</span> · <span class="kbd-clickable" onclick="openDeleteConfirmation()" title="click to delete agent"><kbd>d</kbd> delete</span> · <span class="kbd-clickable" onclick="closeDetailView()" title="click to close detail"><kbd>esc</kbd> close</span>
        </div>
        <div class="footer-right">
            <span class="status-compact" data-tooltip="https: 8443 · http: 8080 · mqtt: 8884 · smtp: 25">console: online</span>
            <span id="alert-status" class="status-compact warning">alerts: loading...</span>
        </div>
    </footer>

    <script src="/js/vendor/chart.js?v={{ v }}"></script>
    <script src="/js/widgets.js?v={{ v }}"></script>
    <!-- Generic widgets -->
    <script src="/widgets/generic/messages.js?v={{ v }}"></script>
    <script src="/widgets/generic/cpu.js?v={{ v }}"></script>
    <script src="/widgets/generic/memory.js?v={{ v }}"></script>
    <script src="/widgets/generic/disk.js?v={{ v }}"></script>
    <script src="/widgets/generic/system.js?v={{ v }}"></script>
    <!-- Proxmox widgets -->
    <script src="/widgets/proxmox/vms.js?v={{ v }}"></script>
    <script src="/widgets/proxmox/containers.js?v={{ v }}"></script>
    <script src="/widgets/proxmox/storage.js?v={{ v }}"></script>
    <script src="/widgets/proxmox/zfs.js?v={{ v }}"></script>
    {% include 'utils.html' %}
    {% include 'detail.html' %}
    {% include 'keyboard.html' %}
    {% include 'invite.html' %}
    {% include 'delete_modal.html' %}
</body>
</html>
