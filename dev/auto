#!/bin/bash
# Development auto-setup: resets console, starts dev agent + virtual agent, watches for .reset file.
# For development only.

set -e
cd "$(dirname "$0")/.."

# Clean up .reset file if it exists
rm -f .reset

echo "Stopping containers..."
docker stop lumenmon-console lumenmon-dev-agent 2>/dev/null || true
docker rm lumenmon-console lumenmon-dev-agent 2>/dev/null || true

echo "Cleaning data..."
rm -rf dev/data 2>/dev/null || true
rm -rf console/data/mqtt/passwd console/data/*.log 2>/dev/null || true
mkdir -p dev/data/mqtt dev/data/agents/virtual-test/mqtt console/data/mqtt

echo "Starting console..."
echo "CONSOLE_HOST=localhost" > console/.env
docker compose -f console/docker-compose.yml up -d --build

echo "Waiting for console..."
sleep 3

echo "Creating invite..."
INVITE=$(docker exec lumenmon-console /app/core/enrollment/invite_create.sh 2>&1 | grep "^lumenmon://" | head -1)
if [ -z "$INVITE" ]; then
    echo "Failed to create invite"
    exit 1
fi
echo "Invite: $INVITE"

echo "Building dev agent..."
docker build -t lumenmon-dev-agent -f dev/Dockerfile.agent .

echo "Registering agent..."
docker run --rm \
    --network host \
    -e LUMENMON_AUTO_ACCEPT=1 \
    -v "$PWD/dev/data:/opt/lumenmon/data" \
    lumenmon-dev-agent \
    /opt/lumenmon/core/setup/register.sh "$INVITE"

echo "Starting dev agent..."
docker run -d \
    --name lumenmon-dev-agent \
    --network host \
    -v "$PWD/dev/data:/opt/lumenmon/data" \
    --restart unless-stopped \
    lumenmon-dev-agent

# === Virtual test agent (inline) ===
echo ""
echo "Setting up virtual test agent..."
VIRTUAL_DATA="dev/data/agents/virtual-test"

VIRTUAL_INVITE=$(docker exec lumenmon-console /app/core/enrollment/invite_create.sh 2>&1 | grep "^lumenmon://" | head -1)
docker run --rm \
    --network host \
    -e LUMENMON_AUTO_ACCEPT=1 \
    -v "$PWD/$VIRTUAL_DATA:/opt/lumenmon/data" \
    lumenmon-dev-agent \
    /opt/lumenmon/core/setup/register.sh "$VIRTUAL_INVITE" >/dev/null 2>&1

MQTT_HOST=$(cat "$VIRTUAL_DATA/mqtt/host")
MQTT_USER=$(cat "$VIRTUAL_DATA/mqtt/username")
MQTT_PASS=$(cat "$VIRTUAL_DATA/mqtt/password")
MQTT_CERT="$PWD/$VIRTUAL_DATA/mqtt/server.crt"

# Function to publish metric (with optional min/max bounds)
publish() {
    local metric="$1" value="$2" type="$3" interval="${4:-60}" min="$5" max="$6"
    local payload="{\"value\":$value,\"type\":\"$type\",\"interval\":$interval"
    [ -n "$min" ] && payload="$payload,\"min\":$min"
    [ -n "$max" ] && payload="$payload,\"max\":$max"
    payload="$payload}"
    mosquitto_pub \
        -h "$MQTT_HOST" -p 8884 \
        -u "$MQTT_USER" -P "$MQTT_PASS" \
        --cafile "$MQTT_CERT" \
        -t "metrics/$MQTT_USER/$metric" \
        -m "$payload" 2>/dev/null
}

# Publish initial system info
publish "generic_hostname" '"virtual-test-agent"' "TEXT" 0
publish "generic_lumenmon_version" '"1.0.0-virtual"' "TEXT" 0

# Publish initial Debian update metrics
UPDATES=$((RANDOM % 15))  # 0-14 total updates
SECURITY=$((UPDATES > 0 ? RANDOM % (UPDATES + 1) : 0))  # Some portion are security
RELEASE=$((RANDOM % 100 < 20 ? 1 : 0))  # 20% chance of release upgrade
FRESHNESS=$((RANDOM % 48))  # 0-47 hours old

publish "debian_updates_total" "$UPDATES" "INTEGER" 3600 0 0
publish "debian_updates_security" "$SECURITY" "INTEGER" 3600 0 0
publish "debian_updates_release" "$RELEASE" "INTEGER" 3600 0 0
publish "debian_updates_age" "$FRESHNESS" "INTEGER" 3600 0 24

echo ""
echo "Done! Dashboard: http://localhost:8080"
echo ""
echo "Logs:  docker logs -f lumenmon-dev-agent"
echo "Stop:  docker stop lumenmon-dev-agent lumenmon-console"
echo ""
echo "Virtual agent publishing metrics. Watching for .reset file..."

# Main loop: publish virtual metrics + watch for .reset
while true; do
    # Check for reset file
    if [ -f .reset ]; then
        echo ""
        echo "[reset] .reset file detected, restarting..."
        rm -f .reset
        exec "$0"
    fi

    # Publish virtual metrics (with min/max bounds for percentages)
    publish "generic_cpu" "$(awk 'BEGIN {printf "%.1f", 5 + rand() * 40}')" "REAL" 1 0 100
    publish "generic_memory" "$(awk 'BEGIN {printf "%.1f", 30 + rand() * 40}')" "REAL" 10 0 100
    publish "generic_disk" "$(awk 'BEGIN {printf "%.1f", 45 + rand() * 10}')" "REAL" 60 0 100
    publish "generic_heartbeat" "$(date +%s)" "INTEGER" 10

    # Proxmox metrics
    publish "proxmox_vms_running" "$((3 + RANDOM % 3))" "INTEGER" 60
    publish "proxmox_vms_total" "8" "INTEGER" 60
    publish "proxmox_containers_running" "$((5 + RANDOM % 4))" "INTEGER" 60
    publish "proxmox_containers_total" "12" "INTEGER" 60
    publish "proxmox_storage_local_used" "$((40 + RANDOM % 20))" "REAL" 60
    publish "proxmox_storage_local_total" "500" "REAL" 60
    publish "proxmox_storage_nas_used" "$((1200 + RANDOM % 400))" "REAL" 60
    publish "proxmox_storage_nas_total" "4000" "REAL" 60

    # ZFS metrics (online min/max = total drives for degraded detection)
    RPOOL_DRIVES=2
    TANK_DRIVES=4
    TANK_ONLINE=$((3 + RANDOM % 2))  # Simulates occasional degraded state
    publish "proxmox_zfs_rpool_drives" "$RPOOL_DRIVES" "INTEGER" 60
    publish "proxmox_zfs_rpool_online" "$RPOOL_DRIVES" "INTEGER" 60 "$RPOOL_DRIVES" "$RPOOL_DRIVES"
    publish "proxmox_zfs_rpool_capacity" "$((35 + RANDOM % 10))" "REAL" 60 0 100
    publish "proxmox_zfs_tank_drives" "$TANK_DRIVES" "INTEGER" 60
    publish "proxmox_zfs_tank_online" "$TANK_ONLINE" "INTEGER" 60 "$TANK_DRIVES" "$TANK_DRIVES"
    publish "proxmox_zfs_tank_capacity" "$((60 + RANDOM % 15))" "REAL" 60 0 100

    # Debian/Ubuntu update metrics - changes every 30 seconds for demo
    if [ "$((SECONDS % 30))" -eq 0 ]; then
        # Simulate dynamic updates with various scenarios
        SCENARIO=$((RANDOM % 4))
        case $SCENARIO in
            0)  # No updates, fresh
                UPDATES=0
                SECURITY=0
                RELEASE=0
                FRESHNESS=$((RANDOM % 12))  # 0-11 hours (fresh)
                ;;
            1)  # Regular updates only
                UPDATES=$((1 + RANDOM % 8))  # 1-8 updates
                SECURITY=0
                RELEASE=0
                FRESHNESS=$((RANDOM % 24))  # 0-23 hours
                ;;
            2)  # Security updates present
                UPDATES=$((5 + RANDOM % 10))  # 5-14 updates
                SECURITY=$((1 + RANDOM % 5))  # 1-5 security
                RELEASE=0
                FRESHNESS=$((RANDOM % 36))  # 0-35 hours
                ;;
            3)  # Critical: release upgrade + updates
                UPDATES=$((10 + RANDOM % 20))  # 10-29 updates
                SECURITY=$((3 + RANDOM % 7))  # 3-9 security
                RELEASE=1
                FRESHNESS=$((24 + RANDOM % 24))  # 24-47 hours (stale)
                ;;
        esac

        publish "debian_updates_total" "$UPDATES" "INTEGER" 3600 0 0
        publish "debian_updates_security" "$SECURITY" "INTEGER" 3600 0 0
        publish "debian_updates_release" "$RELEASE" "INTEGER" 3600 0 0
        publish "debian_updates_age" "$FRESHNESS" "INTEGER" 3600 0 24
    fi

    sleep 1
done
